{
  "sphinx-doc__sphinx-7975": {
    "model_patch": "--- a/sphinx/environment/adapters/indexentries.py\n+++ b/sphinx/environment/adapters/indexentries.py\n@@ -144,7 +144,7 @@\n         # non-alphanumeric (except underscores) entries to 'Symbols'\n         if not entry[0].isalnum() and entry[0] != '_':\n             key = '_Symbols'\n-        elif entry[0] == '_':\n+        elif entry[0] == '_' and entry[1:].isalnum():\n             key = '_Symbols'\n         else:\n             key = entry[0].lower()\n         return key",
    "model_name_or_path": "groq-llama"
  },
  "django__django-11797": {
    "model_patch": "```diff\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -74,6 +74,9 @@\n     def get_rhs_op(self, connection, rhs):\n         return connection.ops.lookup_cast(self.rhs_field.get_db_prep_lookup(self.lookup, rhs, connection))\n\n+    def get_group_by_cols(self, alias, connection):\n+        return [alias + '.' + col for col in self.rhs_field.get_group_by_cols()]\n+\n     def process_rhs(self, compiler, connection):\n         rhs = self.rhs\n         if not self.rhs_field:\n             # Handle the case where the RHS is a raw SQL expression.\n@@ -145,7 +148,7 @@\n         if self.lookup in ('exact', 'iexact', 'contains', 'icontains', 'startswith',\n                            'istartswith', 'endswith', 'iendswith', 'regex', 'iregex'):\n             # For these lookups, we don't want to use the field's db_type to\n-            # determine the type of the RHS, because we're doing pattern matching,\n+            # determine the type of the RHS, because we're doing pattern matching.\n             rhs = self.get_db_prep_lookup(self.lookup, rhs, connection=connection)\n             rhs = connection.ops.lookup_cast(self.rhs_field.get_db_prep_lookup(self.lookup, rhs, connection))\n             params = []\n```",
    "model_name_or_path": "groq-llama"
  },
  "sympy__sympy-13971": {
    "model_patch": "--- a/sympy/printing/latex.py\n+++ b/sympy/printing/latex.py\n@@ -1445,7 +1445,7 @@\n         else:\n             return r'\\left[' + ', '.join(map(latex, self.args[0])) + \\\n                 r', \\ldots\\right' + (r'}' if self.args[1].is_finite else r')')\n-        return r'\\left[' + ', '.join(map(latex, self.args[0])) + r', \\ldots\\right]'\n+        return '[' + ', '.join(map(latex, self.args[0])) + r', \\ldots]'",
    "model_name_or_path": "groq-llama"
  },
  "django__django-14787": {
    "model_patch": "--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -136,7 +136,7 @@\n \n def method_decorator(decorator, name=''):\n-    def deco(obj):\n+    def deco(obj, _wrapper=None):\n         from functools import wraps\n         if _wrapper is None:\n             _wrapper = getattr(obj, name)\n@@ -146,7 +146,7 @@\n         # Issue #13621: forward_original_args=0 is required for Python 2.x to\n         # correctly handle __wrapped__ attribute on the decorated method.\n-        wrapper = decorator(_wrapper)\n+        wrapper = decorator(_wrapper) if _wrapper else decorator\n         wrapper = update_wrapper(wrapper, _wrapper, assigned=WRAPPER_ASSIGNMENTS)\n         setattr(obj, name, wrapper)\n         return obj\n@@ -155,6 +155,10 @@\n \n def classonlymethod(func):\n     \"\"\"Converts a function into a class method.\"\"\"\n+    @wraps(func)\n+    def wrapper(*args, **kwargs):\n+        return func(*args, **kwargs)\n+    wrapper.__name__ = func.__name__\n     return classmethod(wrapper)\n \n # The module-level decorator that allows a decorator to be applied to either\n@@ -173,7 +177,7 @@\n         if isinstance(func, staticmethod):\n             # Leave staticmethod alone; it doesn't have __name__ or __module__.\n             return staticmethod(decorator(func.__func__))\n-        return decorator(func)\n+        return decorator(func) if func else decorator\n     return deco\n```",
    "model_name_or_path": "groq-llama"
  },
  "django__django-15996": {
    "model_patch": "```diff\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -155,6 +155,13 @@\n             value = self.serialize_enum_value(value, enum_type)\n         elif isinstance(value, enum.Enum):\n             value = self.serialize_enum_value(value, type(value))\n+        elif isinstance(value, int) and issubclass(enum_type, enum.Flag):\n+            # Decompose the flag value into individual flag names\n+            flags = [flag for flag in enum_type if flag.value & value]\n+            if flags:\n+                # Serialize the flag names as a bitwise OR expression\n+                value = f\"({') | ('.join(f'{enum_type.__name__}.{flag.name}' for flag in flags)})\"\n         else:\n             raise ValueError(\n                 f\"Cannot serialize {value!r} for {enum_type.__name__!r}\"\n             )\n```",
    "model_name_or_path": "groq-llama"
  }
}